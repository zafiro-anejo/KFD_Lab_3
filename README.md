# Сравнение производительности кастомного и встроенного TOML сериализаторов
## Описание проекта
Этот проект реализует сравнительный анализ производительности различных подходов к TOML сериализации и десериализации данных. Проект включает четыре различных реализации сериализаторов с поддержкой параллельного выполнения.

## Архитектура решения

### Основные компоненты
1. Data класс Template - тестовая структура данных для сериализации
2. Кастомный TOML сериализатор - рефлексивная реализация
3. Встроенный TOML сериализатор - оптимизированная ручная реализация
4. Параллельные версии обоих сериализаторов
5. Система бенчмаркинга - измерение производительности

## Детальное описание сериализаторов
### 1. Кастомный TOML сериализатор (TomlSerialization)

#### Особенности реализации:
1. Использует Kotlin reflection для анализа структуры классов
2. Рекурсивно обрабатывает вложенные объекты и коллекции
3. Автоматически определяет типы полей через KParameter.type.classifier
4. Поддерживает сложные структуры данных (List, Map, вложенные data class)

#### Ключевые методы:
1. buildTomlString() - рекурсивное построение TOML строки
2. parseTomlToObject() - парсинг TOML в объекты с обработкой ошибок
3. formatValue() - форматирование значений согласно TOML спецификации

#### Преимущества:
1. Универсальность - работает с любыми data class
2. Автоматическая обработка сложных типов
3. Расширяемость через добавление поддержки новых типов


### 2. Встроенный TOML сериализатор (BuiltInTomlSerialization)

#### Особенности реализации:
1. Жестко закодированная логика для конкретного класса Template
2. Прямой доступ к полям без reflection
3. Минимальные накладные расходы

#### Преимущества:
1. Максимальная производительность
2. Простота реализации
3. Минимальное использование памяти

#### Недостатки:
1. Не универсален - требует переписывания для каждого нового типа
2. Ограниченная функциональность

### 3. Параллельные реализации

#### Стратегия параллелизации:
1. Использует CompletableFuture и ExecutorService
2. Пороговое значение 1000 записей для переключения в параллельный режим
3. Work-stealing пул потоков для оптимального распределения нагрузки

## Пример результатов тестирования 
```
Кастомная TOML Сериализация:
  10000 записей: 19880,72 ед/сек
  100000 записей: 704225,35 ед/сек
  1000000 записей: 1007049,35 ед/сек

Кастомная TOML Десериализация:
  10000 записей: 8190,01 ед/сек
  100000 записей: 15119,44 ед/сек
  1000000 записей: 15257,16 ед/сек

Встроенная TOML Сериализация:
  10000 записей: 172413,79 ед/сек
  100000 записей: 781250,00 ед/сек
  1000000 записей: 969932,10 ед/сек

Встроенная TOML Десериализация:
  10000 записей: 15772,87 ед/сек
  100000 записей: 16496,21 ед/сек
  1000000 записей: 16597,79 ед/сек

Параллельная Кастомная TOML Сериализация:
  10000 записей: 357142,86 ед/сек
  100000 записей: 3225806,45 ед/сек
  1000000 записей: 1869158,88 ед/сек

Параллельная Кастомная TOML Десериализация:
  10000 записей: 48780,49 ед/сек
  100000 записей: 53078,56 ед/сек
  1000000 записей: 45335,03 ед/сек

Параллельная Встроенная TOML Сериализация:
  10000 записей: 769230,77 ед/сек
  100000 записей: 1960784,31 ед/сек
  1000000 записей: 3021148,04 ед/сек

Параллельная Встроенная TOML Десериализация:
  10000 записей: 52910,05 ед/сек
  100000 записей: 54141,85 ед/сек
  1000000 записей: 43687,20 ед/сек

АНАЛИЗ ПРОИЗВОДИТЕЛЬНОСТИ КАСТОМНОГО И ВСТРОЕННОГО СЕРИАЛИЗАТОРОВ:
  Последовательная сериализация: Кастомная/Встроенная = 1,04
  Последовательная десериализация: Кастомная/Встроенная = 0,92
  Параллельная сериализация: Кастомная/Встроенная = 0,62
  Параллельная десериализация: Кастомная/Встроенная = 1,04
```

## Выводы по производительности сериализаторов
### Сравнение сериализаторов

- Специализированный сериализатор всегда быстрее универсального
- Жестко закодированная логика исключает накладные расходы
- Разрыв увеличивается в параллельном режиме
- Универсальный сериализатор проигрывает в скорости, но выигрывает в гибкости
- Reflection добавляет overhead
- Подходит для часто меняющихся структур данных

### Сериализация vs Десериализация
- Сериализация быстрее десериализации
- Преобразование объекта в текст проще обратного процесса
- Десериализация требует парсинга и валидации данных

### Параллельная обработка

- Параллелизация эффективна только для больших объемов
- Малые данные: overhead превышает выгоду
- Большие данные: значительное ускорение
